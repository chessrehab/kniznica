
I/O FILE int open(const char *pathname, int flags, .../* mode_t mode */);  RETURNS: filedescriptor or -1(error) FLAGS: O_RDONLY,O_WRONLY,O_RDWR,O_CREAT,O_TRUNC,O_APPEND...   MODE:S_IRUSR,S_IWUSR,S_IRGRP,S_IWGRP,S_IROTH,S_IWOTH...#INCLUDES: <sys/stat.h> <fcntl.h>
I/O FILE int creat(const char *pathname, mode_t mode); RETURNS: filedescriptor or -1(error)  MODE:S_IRUSR,S_IWUSR,S_IRGRP,S_IWGRP,S_IROTH,S_IWOTH...#INCLUDES:<unistd.h>
I/O FILE ssize_t read(int fd, void *buffer,size_t count); RETURNS: nr of bytes read or 0(EOF) or -1(error) #INCLUDES:<unistd.h>
I/O FILE ssize_t write(int fd, const void *buffer, size_t count); RETURNS nr of bytes written or -1(error) #INCLUDES:<unistd.h>
I/O FILE int close(int fd); RETURNS 0 or -1(error) #INCLUDES:<unistd.h>
I/O FILE off_t lseek(int fd, off_t offset, int whence); RETURNS:new offset or -1(error) WHENCE: SEEK_SET,SEEK_END,SEEK_CUR  #INCLUDES:<unistd.h>
I/O FILE int fcntl(int fd,int cmd,...); RETURNS:value dpnd on cmd or -1(error) CMD: F_GETFL,F_SETFL,F_DUPFD, FDUPFD_CLOEXEC #INCLUDES:<fcntl.h>
I/O FILE int dup(int oldfd); RETURNS:new fd or -1(error) #INCLUDES:<unistd.h>
I/O FILE int dup2(int oldfd,int newfd); RETURNS: newfd or -1(error) #INCLUDES:<unistd.h>
I/O FILE int dup3(int oldfd,int newfd,int flags); RETURNS: newfd or -1(error)
I/O FILE ssize_t pread(inf fd,void *buffer,size_t count,off_t offset); RETURNS: nr of bytes read or 0 on EOF or -1(error) #INCLUDES:<unistd.h>
I/O FILE ssize_t pwrite(int fd,const void *buffer,size_t count,off_t offset); RETURNS: nr of bytes written or 0 on EOF or -1(error) #INCLUDES:<unistd.h>
I/O FILE ssize_t readv(int fd,struct *iovec,int iovcnt); RETURNS:nr of bytes read or 0 (EOF) or -1(error) #INCLUDES:<sys/uio.h>
I/O FILE ssize_t writev(int fd,const struct *iovec,int iovcnt); RETURNS:nr of bytes written or -1(error) #INCLUDES:<sys/uio.h>
I/O FILE ssize_t preadv(int fd,struct *iovec,int iovcnt,off_t offset); RETURNS:nr of bytes or 0(EOF) or -1(error) #INCLUDES:<sys/uio.h>
I/O FILE ssize_t pwritev(int fd,const struct *iovec,int iovcnt,off_t offset); RETURNS:nr of bytes written or -1(error) #INCLUDES:<sys/uio.h>
I/O FILE int truncate(const char *pathname,off_t length); RETURNS:0 or -1(error) #INCLUDES:<unistd.h>
I/O FILE int ftruncate(int fd,off_t length); RETURNS:0 or -1(error) #INCLUDES:<unistd.h>
I/O FILE int mkstemp(char *template); RETURNS: fd or -1(error) #INCLUDES:<stdlib.h>

PROCESS pid_t getpid(void); RETURNS:void #INCLUDES:<unistd.h>
PROCESS pid_t getppid(void) RETURNS:void #INCLUDES:<unistd.h>
PROCESS char *getenv(const char *name); RETURNS: pointer to value/string or NULL(no such var) #INCLUDES:<stdlib.h>
PROCESS extern char **environ; RETURNS: global variable -pointer to pointers to env. variables
PROCESS int putenv(char *string); RETURNS:0(success) or nonzero(error), string is name=value #INCLUDES:<stdlib.h>
PROCESS int setenv(const char *name,const char *value,int overwrite); RETURNS:0(success) or -1(error) #INCLUDES:<stdlib.h>
PROCESS int unsetenv(const char *name); RETURNS:0(succes) or -1(error) #INCLUDES:<stdlib.h>
PROCESS int clearenv(void); RETURNS:0(success) or nonzero(error), equal to environ=NULL; #INCLUDES:<stdlib.h>
PROCESS int setjmp(jmp_buf env); RETURNS:0 on initial call, nonzero on return via longjmp() #INCLUDES:<setjmp.h>
PROCESS void longjmp(jmp_buf env,int val); RETURNS:void returns to setjump with value val #INCLUDES:<setjmp.h>

MEMORY	int brk(void *end_data_segment); RETURNS:0(success) or -1(error) #INCLUDES:<unistd.h>
MEMORY void *sbrk(intptr_t increment); RETURNS:previous program break or (*void)-1 on error #INCLUDES:<unistd.h>
MEMORY void *malloc(size_t size); RETURNS:pointer to allocated memory or NULL(error) #INCLUDES:<stdlib.h>
MEMORY free(void *ptr); RETURNS:void #INCLUDES:<stdlib.h>
MEMORY void *calloc(size_t numitems,size_t size); RETURNS:pointer to allocated memory or NULL(error) #INCLUDES:<stdlib.h>
MEMORY void *realloc(void *ptr,size_t size); RETURNS:pointer to reallocated memory or NULL(error) #INCLUDES:<stdlib.h>
MEMORY void *memalign(size_t boundary,size_t size); RETURNS:pointer to allocated memory or NULL(error) #INCLUDES:<malloc.h>
MEMORY int posix_memalign(void **memptr,size_t alignment,size_t size); RETURNS: 0(success) or errnum(error) #INCLUDES:<stdlib.h>
MEMORY void *alloca(size_t size); RETURNS:pointer to allocated memory on the stack #INCLUDES:<alloca.h>

USERS struct passwd *getpwname(const char *name); RETURNS:pointer to structure passwd[pw_name,pw_passwd,pw_uid,pw_gid,pw_gecos,pw_dir,pw_shell] or NULL(error) #INCLUDES:<pwd.h>
USERS struct passwd *getpwuid(uid_t uid); RETURNS:pointer to structure passwdd[pw_name,pw_passwd,pw_uid,pw_gid,pw_gecos,pw_dir,pw_shell] or NULL(error) #INCLUDES:<pwd.h>
USERS struct group *getgrnam(const char *name); RETURNS:pointer to struct group[gr_name,gr_passwd,gr_gid,**gr_mem] ot NULL(error) #INCLUDES:<grp.h>
USERS struct group *getgrgid(gid_t gid); RETURNS:pointer to struct group[gr_name,gr_passwd,gr_gid,**gr_mem] ot NULL(error) #INCLUDES:<grp.h>
USERS struct passwd *getpwent(void); RETURNS:pointer to structure passwd entry or NULL(error) #INCLUDES:<pwd.h>
USERS void setpwent(void); RETURNS:void -resets the entry point of getpwent() #INCLUDES:<pwd.h>
USERS void endpwent(void); RETURNS:void -ends the entry of getpwent()-closes down #INCLUDES:<pwd.h>
USERS struct group *getgrent(void); RETURNS:pointer to structure group entry or NULL(error) #INCLUDES:<grp.h>
USERS void setgrent(void); RETURNS:void -resets the entry point of getgrent() #INCLUDES:<grp.h>
USERS void endgrent(void); RETURNS:void -ends the entry of getgrent()-closes down #INCLUDES:<grp.h>
USERS struct spwd *getspnam(const char *name); RETURNS:pointer to structure spwd[sp_namp,sp_pwdp,sp_lstchg,sp_min,sp_max,sp_warn,sp_inact,sp_expire] #INCLUDES:<shadow.h>
USERS struct spwd *getspent(void); RETURNS:pointer to structure spwd entry or NULL(error) #INCLUDES:<shadow.h>
USERS void setspent(void); RETURNS:void -resets the entry point of getspent() #INCLUDES:<shadow.h>
USERS void endspent(void); RETURNS:void -ends the entry of getspent()-closes down #INCLUDES:<shadow.h>
USERS char *crypt(const char *key,const *char salt); RETURNS:pointer to encrtypted pwd or NULL(error) #INCLUDES:<unistd.h>
USERS char *getpass(const *char prompt); RETURNS:pointer to entered pwd or NULL(error) #INCLUDES:<unistd.h>

PROCESS_CREDENT uid_t getuid(void); RETURNS:real user id of calling process #INCLUDES:<unistd.h>
PROCESS_CREDENT uid_t geteuid(void); RETURNS:effective user id of calling process#INCLUDES:<unistd.h>
PROCESS_CREDENT gid_t getgid(void); RETURNS:real group id of calling process #INCLUDES:<unistd.h>
PROCESS_CREDENT gid_t getegid(void); RETURNS: effective group id of a calling process #INCLUDES:<unistd.h>
PROCESS_CREDENT int setuid(uid_t uid); RETURNS:0 on success or -1(error) #INCLUDES:<unistd.h>
PROCESS_CREDENT int setgid(gid_t gid); RETURNS:0 on success or -1(error) #INCLUDES:<unistd.h>
PROCESS_CREDENT int seteuid(uid_t euid); RETURNS:0 on success or -1(error) #INCLUDES:<unistd.h>
PROCESS_CREDENT int setegid(gid_t egid); RETURNS:0 on success or -1(error) #INCLUDES:<unistd.h>
PROCESS_CREDENT int setreuid(uid_t ruid,uid_t euid); RETURNS:0 on success or -1(error),args can be -1 for omit #INCLUDES:<unistd.h>
PROCESS_CREDENT int setregid(gid_t rgid,gid_t egid); RETURNS:0 on success or -1(error),args can be -1 for omit  #INCLUDES:<unistd.h>
PROCESS_CREDENT int getresuid(uid_t *ruid,uid_t *euid,uid_t *suid); RETURNS:0 on success or -1(error) #INCLUDES:<unistd.h>
PROCESS_CREDENT int getresgid(gid_t *rgid,gid_t *egid,gid_t *sgid); RETURNS:0 on success or -1(error) #INCLUDES:<unistd.h>
PROCESS_CREDENT int setresuid(uid_t ruid,uid_t euid,uid_t suid); RETURNS:0 on success or -1(error),args can be -1 for omit  #INCLUDES:<unistd.h>
PROCESS_CREDENT int setresgid(gid_t rgid,gid_t egid,gid_t sgid); RETURNS:0 on success or -1(error),args can be -1 for omit  #INCLUDES:<unistd.h>
PROCESS_CREDENT int setfsuid(uid_t fsuid); RETURNS:previous fsuid #INCLUDES:<sys/fsuid.h>
PROCESS_CREDENT int setfsgid(gid_t fsgid); RETURNS:previous fsgid #INCLUDES:<sys/fsuid.h>
PROCESS_CREDENT int getgroups(int gidsetsize,gid_t grouplis[]); RETURNS: nr of group IDs placed in grouplist on success or -1(error) #INCLUDES:<unistd.h>
PROCESS_CREDENT int setgroups(size_t gidsetsize,const gid_t *grouplis); RETURNS:0 on success or -1(error) #INCLUDES:<grp.h>
PROCESS_CREDENT int initgroups(const char *user,gid_t group); RETURNS:0 on success or -1(error) #INCLUDES:<grp.h>

TIME int gettimeofday(struct timeval *tv,struct timezone *tz); RETURNS: 0 or -1(error) ,struct timeval:[time_t tv_sec(secs),suseconds_t tv_usec(micros)] #INCLUDES:<sys/time.h>
TIME time_t time(time_t *timep); RETURNS:number of seconds since Epoch or -1(error) ,usually use NULL as arg #INCLUDES:<time.h>
TIME char *ctime(const time_t *timep); RETURNS:pointer to string or NULL(error) #INCLUDES:<time.h>
TIME struct tm *gmtime(const time_t *timep); RETURNS:pointer to structure tm with broken down time attrs,struct tm:[tm_sec,tm_min,tm_hour,tm_mday,tm_mon,tm_year...etc] or NULL(error) #INCLUDES:<time.h>
TIME struct tm *localtime(const time_t *timep); RETURNS:pointer to structure tm with broken down time attrs or NULL(error) #INCLUDES:<time.h>
TIME time_t mktime(struct tm *timeptr); RETURNS: seconds since Epoch corr. to the struct in the attr or -1(error) #INCLUDES:<time.h>
TIME char *asctime(const struct tm *timeptr); RETURNS: pointer to preformatted string or NULL(error) #INCLUDES:<time.h>
TIME size_t strftime(char *outstr,size_t maxsize,const char *format,const struct tm *timeptr); RETURNS:nr of bytes placed in outstr or NULL(error) %c(all)%d(day)%F(ISO date)%m(month) %Y(YYYY)  #INCLUDES<time.h>
TIME char *strptime(const char *str,const char *format,struct tm *timeptr); RETURNS:ptr to next unprocessed char or NULL(error) #INCLUDES:<time.h>
TIME char *setlocale(int category,const char *locale); RETURNS:ptr to a string with new locale or NULL(error) #INCLUDES:<locale.h>
TIME int settimeoftheday(const struct timeval *tv,const struct timezone *tz); RETURNS: 0 or -1(error) #INCLUDES<sys/time.h>
TIME int adjtime(struct timeval *delta,struct timeval *olddelta); RETURNS:0 on success or -1(error) #INCLUDES:<sys/time.h>
TIME clock_t times(struct tms *buf); RETURNS:nr of clock ticks or -1(error),struct tms:[tms_utime,tms_stime,tms_cutime,tms_cstime] #INCLUDES:<sys/times.h>
TIME clock_t clock(void); RETURNS:total cpu time used by calling process or -1(error) #INCLUDES:<time.h>

SYSTEM long sysconf(int name); RETURNS value of limit or -1(error/indetermined) [_SC_ARG_MAX._SC_CLK_TCK,_SC_LOGIN_NAME_MAX,_SC_OPEN_MAX,_SC_NGROUPS_MAX,_SC_PAGE_SIZE,_SC_RTSIG_MAX,_SC_SIGQUEUE_MAX,_SC_STREAM_MAX] #INCLUDES:<unistd.h>
SYSTEM long pathconf(const char *pathname,int name); RETURNS:value of limit or -1(error/indetermined) [_PC_NAME_MAX,_PC_PATH_MAX,_PC_PIPE_BUF] #INCLUDES:<unistd.h>
SYSTEM long fpathconf(int fd,int name); RETURNS:value of limit or -1(error/indetermined) [_PC_NAME_MAX,_PC_PATH_MAX,_PC_PIPE_BUF]  #INCLUDES:<unistd.h>
SYSTEM int uname(struct utsname *utsbuf): RETURNS:0 or -1(error) struct[ chars *sysname,nodename,release,version,machine,domainname] #INCLUDES:<sys/utsname.h>

I/O FILE BUFFERING int setvbuf(FILE *stream,char *buf,int mode,size_t size); RETURNS: 0 or nonzero(error) mode[_IONBF,_IOLBF,_IOFBF]  #INCLUDES:<stdio.h>
I/O FILE BUFFERING void setbuf(FILE *stream,char *buf); RETURNS:void  #INCLUDES:<stdio.h>
I/O FILE BUFFERING void setbuffer(FILE *stream,char *buf,size_t size); RETURNS:void #INCLUDES:<stdio.h>
I/O FILE BUFFERING int fflush(FILE *stream); RETURNS: 0 or EOF(error) #INCLUDES:<stdio.h>
I/O FILE BUFFERING int fsync(int fd); RETURNS:0 or -1(error) #INCLUDES:<unistd.h>
I/O FILE BUFFERING int fdatasync(int fd); RETURNS:0 or -1(error) #INCLUDES:<unistd.h>
I/O FILE BUFFERING void sync(void); RETURNS:void #INCLUDES:<unistd.h>
I/O FILE BUFFERING int posix_fadvise(int fd,off_t offset,off_t len,int advice); RETURNS:0 or positive nr(error) advice[POSIX_FADV_NORMAL,POSIX_FADV_SEQUENTIAL,POSIX_FADV_RANDOM,POSIX_FADV_WILLNEED,POSIX_FADV_DONTNEED,POSIX_FADV_NOREUSE] #INCLUDES:<fcntl.h>
I/O FILE BUFFERING int fileno(FILE *stream); RETURNS: fd or -1(error) #INCLUDES:<stdio.h>
I/O FILE BUFFERING FILE *fdopen(int fd,const char *mode); RETURNS:new file ptr or NULL(error) #INCLUDES:<stdio.h>

FILESYS int mount(const char *source,const char *target,const char *fstype, unsigned long mountflags,const void *data); RETURNS:0 or -1 mountflags[MS_BIND,MS_DIRSYNC,MS_MANDLOCK,MS_MOVE,MS_NOATIME,MS_NODEV,MS_NODRIRATIME,MS_NOEXEC,MS_NOSUID,MS_RDONLY,MS_REC,MS_RELATIME.MS_REMOUNT,MS_STRICTATIME,MS_SYNCHRONOUS] #INCLUDES:<sys/mount.h>
FILESYS int umount(const char *target); RETURNS:0 or -1(error) #INCLUDES:<sys/mount.h>
FILESYS int umount2(const char *target,int flags); RETURNS:0 or -1(error) flags[MNT_DETACH,MNT_EXPIRE,MNT_FORCE,UMOUNT_NOFOLLOW] #INCLUDES:<sys/mount.h>
FILESYS int statvfs(const char *pathname,struct statvfs *ststvsbuf); RETURNS:0 or -1(error) struct statvfs[ul f_bsize,ul f_frsize,fsblkcnt_t f_blocks,f_bfree,f_bavail,fsfilcnt f_files,f_ffree,f_avail,ul f_fsid,f_flag,f_namemax] #INCLUDES:<sys/statvfs.h>
FILESYS int fstatvfs(int fd,struct statvfs *statvfsbuf); RETURNS:0 or -1(error) struct statvfs[ul f_bsize,ul f_frsize,fsblkcnt_t f_blocks,f_bfree,f_bavail,fsfilcnt f_files,f_ffree,f_avail,ul f_fsid,f_flag,f_namemax] #INCLUDES:<sys/statvfs.h>

FILE ATTR int stat(const char *pathname,struct stat *statbuf); RETURNS:0 or -1(error) struct[st_dev,st_ino,st_mode,st_nlink,st_uid,st_gid,st_rdev,st_size,st_blksize,st_blocks,st_atime,st_mtime,st_ctime] mode[S_IFREG,S_IFDIR,S_IFCHR,S_IFBLK,S_IFIFO,S_IFSOCK,S_IFLNK] #INCLUDES:<sys/stat.h>
FILE ATTR int lstat(const char *pathname,struct stat statbuf); RETURNS:0 or -1(error) struct[st_dev,st_ino,st_mode,st_nlink,st_uid,st_gid,st_rdev,st_size,st_blksize,st_blocks,st_atime,st_mtime,st_ctime] #INCLUDES:<sys/stat.h>
FILE ATTR int fstat(int fd,struct stat *statbuf); RETURNS:0 or -1(error) struct[st_dev,st_ino,st_mode,st_nlink,st_uid,st_gid,st_rdev,st_size,st_blksize,st_blocks,st_atime,st_mtime,st_ctime #INCLUDES:<sys/stat.h>
FILE ATTR int utime(const char *pathname,const struct utimbuf *buf); RETURNS:0 or -1(error) utimbuf[actime,modtime] #INCLUDES:<utime.h>
FILE ATTR int utimes(const char *pathname,const struct timeval tv[2]); RETURNS:0 or -1(error) #INCLUDES:<sys/time.h>
FILE ATTR int futimes(int fd,const struct timeval tv[2]); RETURNS:0 or -1(error) #INCLUDES:<sys/time.h>
FILE ATTR int lutimes(const char *pathname,const struct timeval tv[2]); RETURNS:0 or -1(error) #INCLUDES:<sys/time.h>
FILE ATTR int utimensat(int dirfd,const char *pathname,const struct timespec times[2],int flags); RETURNS:0 or -1(error) struct timespec[tv_sec,tv_nsec] #INCLUDES:<sys/stat.h>
FILE ATTR int futimens(int fd,const struct timespec times[2]); RETURNS 0 or -1(error) struct timespec[tv_sec,tv_nsec] #INCLUDES:<sys/stat.h>
FILE ATTR int chown(const char *pathname,uid_t owner, gid_t group); RETURNS:0 or -1(error) #INCLUDES:<unistd.h>
FILE ATTR int lchown(const char *pathname,uid_t owner,gid_t group); RETURNS:0 or -1(error) #INCLUDES:<unistd.h>
FILE ATTR int fchown(int fd,uid_t owner,gid_t group); RETURNS:0 or -1(error) #INCLUDES:<unistd.h>
FILE ATTR int access(const char *pathname,int mode); RETURNS:0 if all granted,-1(otherwise) mode[F_OK,R_OK,W_OK,X_OK]  #INCLUDES:<unistd.h>
FILE ATTR mode_t umask(mode_t mask); RETURNS:previous mask #INCLUDES:<sys/stat.h>
FILE ATTR int chmod(const char *pathname,mode_t mode); RETURNS:0 or -1(error) mode[S_ISUID,S_ISGID,S_ISVTX,S_IRUSR,S_IWUSR,S_IXUSR,S_IRGRP,S_IWGRP,S_IXGRP,S_IROTH,S_IWOTH,S_IXOTH] #INCLUDES:<sys/stat.h>
FILE ATTR int fchmod(int fd,mode_t mode); RETURNS:0 or -1(error) mode[S_ISUID,S_ISGID,S_ISVTX,S_IRUSR,S_IWUSR,S_IXUSR,S_IRGRP,S_IWGRP,S_IXGRP,S_IROTH,S_IWOTH,S_IXOTH] #INCLUDES:<sys/stat.h>
FILE ATTR EXT int setxattr(const char *pathname,const char *name,const void *value,size_t size,int flags); RETURNS:0 or -1(error) #INCLUDES:<sys/xattr.h>
FILE ATTR EXT int lsetxattr(const char *pathname,const char *name,const void *value,size_t size,int flags); RETURNS:0 or -1(error) #INCLUDES:<sys/xattr.h>
FILE ATTR EXT int fsetxattr(int fd, const char *name,const void *value,size_t size,int flags); RETURNS:0 or -1(error) #INCLUDES:<sys/xattr.h>
FILE ATTR EXT ssize_t getxattr(const char *pathname,const char *name,void *value,size_t size); RETURNS:size of value or -1(error) #INCLUDES:<sys/xattr.h>
FILE ATTR EXT ssize_t lgetxattr(const char *pathname,const char *name,void *value,size_t size); RETURNS:size of value or -1(error) #INCLUDES:<sys/xattr.h>
FILE ATTR EXT ssize_t fgetxattr(int fd,const char *name,void *value,size_t size); RETURNS:size of value or -1(error) #INCLUDES:<sys/xattr.h>
FILE ATTR EXT int removexattr(const char *pathname,const char *name); RETURNS:0 or -1(error) #INCLUDES:<sys/xattr.h>
FILE ATTR EXT int lremovexattr(const char *pathname,const char *name); RETURNS:0 or -1(error) #INCLUDES:<sys/xattr.h>
FILE ATTR EXT int fremovexattr(int fd,const char *name); RETURNS:0 or -1(error) #INCLUDES:<sys/xattr.h>
FILE ATTR EXT ssize_t listxattr(const char *pathname,char *list,size_t size); RETURNS:nr of bytes copied into list or -1(error) #INCLUDES:<sys/xattr.h>
FILE ATTR EXT ssize_t llistxattr(const char *pathname,char *list,size_t size); RETURNS:nr of bytes copied into list or -1(error) #INCLUDES:<sys/xattr.h>
FILE ATTR EXT ssize_t flistxattr(int fd,char *list,size_t size); RETURNS:nr of bytes copied into list or -1(error) #INCLUDES:<sys/xattr.h>

DIRS int link(const char *oldpath,const char *newpath); RETURNS:0 or -1(error) #INCLUDES:<unistd.h>
DIRS int unlink(const char *pathname); RETURNS:0 or -1(error) #INCLUDES:<unistd.h>
DIRS int rename(const char *oldpath,const char *newpath); RETURNS:0 or -1(error) #INCLUDES:<stdio.h>
DIRS int symlink(const char *filepath,const char *linkpath); RETURNS:0 or -1(error) #INCLUDES:<unistd.h>
DIRS ssize_t readlink(const char *pathname,char *buffer,size_t bufsiz); RETURNS:nr bytes in buffer or -1(error) #INCLUDES:<unistd.h>
DIRS int mkdir(const char *pathname,mode_t mode); RETURNS:0 or -1(error) #INCLUDES:<sys/stat.h>
DIRS int rmdir(const char *pathname); RETURNS:0 or -1(error) #INCLUDES:<unistd.h>
DIRS int remove(const char *pathname); RETURNS:0 or -1(error) #INCLUDES:<stdio.h>
DIRS DIR *opendir(const char *dirpath); RETURNS:dir stream handle or NULL(error) #INCLUDES:<dirent.h>
DIRS DIR *fdopendir(int fd); RETURNS:dir stream handle or NULL(error) #INCLUDES:<dirent.h>
DIRS struct dirent *readdir(DIR *dirp); RETURNS:ptr to struct of next dir entry or NULL(error or end of entries) #INCLUDES:<dirent.h>
DIRS void rewinddir(DIR *dirp); RETURNS:void #INCLUDES:<dirent.h>
DIRS int closedir(DIR *dirp); RETURNS:0 or -1(error) #INCLUDES:<dirent.h>
DIRS int dirfd(DIR *dirp); RETURNS:fd or -1(error) #INCLUDES:<dirent.h>
DIRS int readdir_r(DIR *dirp,struct dirent *entry,struct dirent **result); RETURNS 0 or pos.num=errno(error) #INCLUDES:<dirent.h>
DIRS int ntfw(const char *dirpath,int (*func) (const char *pathname,const struct stat *statbuf,int typeflag,struct FTW *ftwbuf),int nopenfd,int flags); RETURNS:0 or -1(error) struct FTW[int base,int level] #INCLUDES:<ftw.h>
DIRS char *getcwd(char *cwdbuf,size_t size); RETURNS:cwdbuf or NULL(error) #INCLUDES:<unistd.h>
DIRS int chdir(const char *pathname); RETURNS:0 or -1(error) #INCLUDES:<unistd.h>
DIRS int fchdir(int fd); RETURNS:0 or -1(error) #INCLUDES:<unistd.h>
DIRS int openat(int dirfd,const char *pathname,int flags,.../*mode_t mode */); RETURNS:fd or -1(error) #INCLUDES:<fcntl.h>
DIRS int chroot(const char *pathname); RETURNS:0 or -1(error) #INCLUDES:<unistd.h>
DIRS char *realpath(const char *pathname,char *resolved_path); RETURNS:ptr to resolved path or NULL(error) #INCLUDES:<stdlib.h>
DIRS char *dirname(char *pathname); RETURNS:ptr to str #INCLUDES:<libgen.h>
DIRS char *basename(char *pathname); RETURNS:ptr to str #INCLUDES:<libgen.h>

FILE EVENTS int inotify_init(void); RETURNS:fd or -1(error) #INCLUDES:<sys/inotify.h>
FILE EVENTS int inotify_add_watch(int fd,const char *pathname,uint32_t mask); RETURNS:wdescriptor or -1(error) events[IN_ACCESS,IN_ATTRIB,IN_CLOSE_WRITE,IN_CLOSE_NOWRITE,IN_CREATE,IN_DELETE,IN_DELETE_SELF,IN_MODIFY_SELF,IN_MOVED_FROM,IN_MOVED_TO,IN_OPEN,IN_ALL_EVENTS,IN_MOVE,IN_CLOSE,IN_DONT_FOLLOW,IN_MASK_ADD,IN_ONESHOT,IN_ONLYDIR,IN_IGNORED,IN_ISDIR,IN_Q_OVERFLOW,IN_UNMOUNT]  #INCLUDES"<sys/inotify.h>
FILE EVENTS int inotify_rm_watch(int fd,int wd); RETURNS:0 or -1(error) #INCLUDES:<sys/inotify.h>
FILE EVENTS int read(int inotifyFd,char *buf,int buf_len); event=(struct inotify_event *) reads from fd returned from inotify_init, cast to ptr to struct inotify_event[int wd,uint32_t mask,uint32_t cookie,uint32_t len, char name[]] ;RETURNS nr of bytes read

SIGNALS ***int signals[SIGABRT-6,SIGALRM-14,SIGBUS-7,SIGCHLD-17,SIGCONT-18,SIGEMT-ud,SIGFPE-8,SIGHUP-1,SIGILL-4,SIGINT-2,SIGIO-29,SIGPOLL,SIGKILL-9,SIGPIPE-13,SIGPROF-27,SIGPWR-30,SIGQUIT-3,SIGSEGV-11,SIGSTKFLT-16,SIGSTOP-19,SIGSYS-31,SIGTERM-15,SIGTRAP-5,SIGTSTP-20,SIGTTIN-21,SIGTTOU-22,SIGURG-23,SIGUSR!-10,SIGUSR2-12,SIGVTALRM-26,SIGWINCH-28,SIGXCPU-24,SIGXFSZ-25
SIGNALS void(*signal(int sig,void (*handler)(int))) (int); RETURNS:pointer to function of the signal handler that is being changed to new handler or SIG_ERR(error) #INCLUDES:<signal.h>
SIGNALS int kill(pid_t pid,int sig); RETURNS:0 or -1(error) pid>0:sent to pid,pid==0:every porc in pids porocess group incl. pid,pid==-1: to all processes pid has permissions to send #INCLUDES:<signal.h>
SIGNALS int raise(int sig); RETURNS:0 or nonzero(error) #INCLUDES<signal.h>
SIGNALS killpg(pid_t pgrp,int sig); RETURNS:0 or -1(error) if pgrp=0: all processes in calling proc prgroup  #INCLUDES:<signal.h>
SIGNALS char *strsignal(int sig); RETURNS:ptr to signal desc string #INCLUDES:<string.h><signal.h>
SIGNALS void psignal(int sig,const char *msg); RETURNS:void #INCLUDES:<signal.h>
SIGNALS int sigemptyset(sigset_t *set); RETURNS:0 or -1(error) #INCLUDES:<signal.h>
SIGNALS int sigfillset(sigset_t *set); RETURNS:0 or -1(error) #INCLUDES:<signal.h>
SIGNALS int sigaddset(const sigset_t *set,int sig); RETURNS:0 or -1(error)  #INCLUDES:<signal.h>
SIGNALS int sigdelset(const sigset_t *set,int sig); RETURNS:0 or -1(error)  #INCLUDES:<signal.h>
SIGNALS int sigismember(const sigset_t *set,int sig); RETURNS: 1 if sig member of set,0 if not or -1(error) #INCLUDES:<signal.h>
SIGNALS int sigandset(sigset_t *dest,sigset_t *left,sigset_t *right); RETURNS: 0 or -1(error) #INCLUDES:<signal.h>
SIGNALS int sigorset(sigset_t *dest, sigset_t *left,sigset_t *right); RETURNS: 0 or -1(error) #INCLUDES:<signal.h>
SIGNALS int sigisemptyset(const sigset_t *set); RETURNS 1 if empty, or 0 #INCLUDES:<signal.h>
SIGNALS int sigprocmask(int how,const sigset_t *set,sigset_t *oldset); RETURNS 0 or -1(error) how[SIG_BLOCK,SIG_UNBLOCK,SIG_SETMASK]  #INCLUDES:<signal.h>
SIGNALS int sigpending(sigset_t *set); RETURNS 0 or -1(error) #INCLUDES:<signal.h>
SIGNALS int sigaction(int sig,const struct sigaction *act,struct sigaction *oldact); RETURNS:0 or -1(error) struct sigaction[union __sigaction_handler:{void (*sa_handler)(int)/void(*sa_sigaction)(int sig,siginfo_t *siginfo,void *ucontext)},sigset_t sa_mask,sa_flags[SA_SIGINFO,SA_RESTART,SA_ONSTACK...]...] struct siginfo_t[si_signo,si_code,sigval si_val,si_pid,si_uid...] si_code[SI_QUEUE,SI_USER,SI_KERNEL,...] #INCLUDES:<signal.h>
SIGNALS int pause(void); RETURNS -1,errno=EINTR #INCLUDES:<unistd.h>
SIGNALS int sigsetjump(sigjmp_buf env,int savesigs); RETURNS:0 on initial call,nonzero on return via siglongjmp() #INCLUDES:<setjmp.h>
SIGNALS void siglongjmp(sigjmp_buf env,int val); RETURNS:void #INCLUDES:<setjmp.h>
SIGNALS void abort(void); RETURNS:void #INCLUDES:<stdlib.h> //equal to raise(SIGABRT) //aborts the calling process with coredump
SIGNALS int sigaltstack(const stack_t *sigstack,stack_t *old_sigstack); RETURNS:0 or -1(error) struct stack_t[void *ss_sp(starting address of alt stack),int ss_flags(SS_ONSTACK,SS_DISABLE),size_t ss_size(size of stack)] #INCLUDES:<signal.h>
SIGNALS int siginterrupt(int sig,int flag); RETURNS 0 or -1(error) flag[1-interrupts blocking syscalls,0-blocking syscalls are resumed] #INCLUDES:<signal.h>
SIGNALS void (*sysv_signal(int sig, void (*handler)(int)) ) (int); RETURNS:previous sig desposition or SIG_ERR on error #INCLUDES:<signal.h>
SIGNALS int sigqueue(pid_t,int sig,const union sigval value); RETURNS:0 or -1(error) union sigval:{int sival_int,void *sival_ptr} #INCLUDES:<signal.h>
SIGNALS int sigsuspend(const sigset_t *mask); RETURNS: -1 with errno set to EINTR #INCLUDES:<signal.h>
SIGNALS int sigwaitinfo(const sigset_t *set,siginfo_t *info); RETURNS: sig nr or -1(error) #INCLUDES:<signal.h>
SIGNALS int sigtimedwait(const sigset_t *set,siginfo_t *info,const struct timespec *timeout); RETURNS: sig nr or -1(error) struct timespec:[time_t tv_sec,long tv_nsec] #INCLUDES:<signal.h>
SIGNALS int signalfd(int fd,const sigset_t *mask,int flags); RETURNS: fd or -1(error); #INCLUDES:<sys/signalfd.h> read from fd:read(sfd,&fdsi,sizeof(struct signalfd_siginfo)) struct signalfd_siginfo[ssi_signo,ssi_errno,ssi_code,ssi_pid,ssi_uid,ssi_fd,ssi_tid,ssi_band,ssi_overrun,ssi_trapno,ssi_status,ssi_status,ssi_int,ssi_ptr,ssi_utime,ssi_stime,ssi_addr]

TIMERS int setitimer(int which,const struct itimerval *new_value,struct itimerval *old_value); RETURNS: 0 or -1(error) which[ITIMER_REAL,ITIMER_VIRTUAL,ITIMER_PROF] struct itimerval[struct timeval it_interval,struct timeval it_value] struct timeval[time_t tv_sec,suseconds_ttv_usec]  #INCLUDES:<sys/time.h>
TIMERS int getitimer(int which,struct itimerval *curr_value); RETURNS:0 or -1(error) #INCLUDES:<sys/time.h>
TIMERS unsigned int alarm(unsigned int seconds); RETURNS:nr of seconds remaining on previous set timer or 0(prev timer wasnt set) #INCLUDES:<unistd.h>
TIMERS unsigned int sleep(unsigned int seconds); RETURNS: 0 on completion or nr of seconds unslept when prematurely terminated  #INCLUDES:<unistd.h>
TIMERS int nanosleep(const timespec *request,struct timespec *remain); #RETURNS: 0 on compl sleep or -1(interrupted sleep) struct timespec[time_t tv_sec,long tv_nsec]  #INCLUDES: <time.h>
TIMERS int clock_gettime(clockid_t clockid,struct timespec *tp); RETURNS:0 or -1(error) clock_id[CLOCK_REALTIME,CLOCK_MONOTONIC,CLOCK_PROCESS_CPUTIME_ID,CLOCk_THREAD_CPUTIME_ID]  #INCLUDES:<time.h>
TIMERS int clock_settime(clockid_t clockid,const struct timespec *tp); RETURNS:0 or -1(error) #INCLUDES:<time.h>
TIMERS int clock_getcpuclockid(pid_t pid,clockid_t *clockid); RETURNS:0 or pos err no(error) #INCLUDES:<time.h>
TIMERS int pthread_getcpuclockid(pthread_t thread,clockid_t *clockid); RETURNS:0 or pos err no (error) #INCLUDES:<time.h>
TIMERS int clock_nanosleep(clockid_t clockid,int flags,const struct timespec *request,struct timespec *remain); RETURNS:0 or a pos er no (error) clockid[CLOCK_REALTIME,CLOCK_MONOTONIC,CLOCK_PROCESS_CPUTIME_I] flags[0, TIMER_ABSTIME] #INCUDES:<time.h> 
TIMERS int timer_create(clockid_t clockid,struct sigevent *evp,timer_t *timerid); RETURNS 0 or -1(error) struct sigevent[int sigev_notify[SIGEV_NONE,SIGEV_SIGNAL,SIGEV_THREAD,SIGEV_THREAD_ID],int sigev_signo,union sigval{int sival_int,void *sival_ptr} sigev_value,union _sigev_un{pid_t _tid, struct _sigev_thread[void (*_function) (union sigval),void *attribute]}    #INCLUDES:<signal.h><time.h>
TIMERS int timer_settime(timer_t timerid,int flags,const struct itimerspec *value,struct itimerspec *old_value); RETURNS:0 or -1(error) struct itimerspec[struct timespec it_interval,struct timespec it_value] struct timespec[time_t tv_sec,long tv_nsec] #INCLUDES:<time.h>
TIMERS int timer gettime(timer_t timerid,struct itimerspec *curr_value); RETURNS:0 or -1(error) #INCLUDES:<time.h>
TIMERS int timer_delete(timer_t timerid); RETURNS:0 or -1(error) #INCLUDES<time.h>
TIMERS int timer_getoverrun(timer_t timerid); RETURNS:timer overrun count or -1(error) #INCLUDES:<time.h>
TIMERS int timerfd_create(int clockid,int flags); RETURNS:fd or -1(error) flags[TFD_CLOEXEC,TFD_NONBLOCK] #INCLUDES:<sys/timerfd.h>
TIMERS int timerfd_settime(int fd,int flags,const struct itimerspec *new_value,struct itimerspec *old_value); RETURNS:0 or -1(error) #INCLUDES:<sys/timerfd.h>
TIMERS int timerfd_gettime(int fd,struct itimerspec *curr_value); RETURNS:0 or -1(error) #INCLUDES:<sys/timerfd.h>

PROCESS CREATION pid_t fork(void); RETURNS:proc id in parent and 0 in child or -1(error) #INCLUDES:<unistd.h>
PROCESS CREATION pid_t vfork(void); RETURNS:proc id of child in parent and 0 in child o -1(error) #INCLUDES:<unistd.h>
PROCESS CREATION void _exit(int status); RETURNS:void #INCLUDES:<unistd.h>
PROCESS CREATION void exit(int status); RETURNS:void #INCLUDES:<stdlib.h>
PROCESS CREATION int atexit(void (*func)(void)); RETURNS:0 or nonzero(error) #INCLUDES:<stdlib.h>
PROCESS CREATION int on_exit(void (*func)(int,void*),void *arg); RETURNS:0 or nonzero(error) #INCLUDES:<stdlib.h>
PROCESS CREATION pid_t wait(int *status); RETURNS:proc id of terminated proc or -1(error) #INCLUDES:<sys/wait.h>
PROCESS CREATION pid_t waitpid(pid_t pid,int *status,int options); RETURNS:child proc id,0 in case no change in status for async,ECHILD if no children to wait for or -1(error) options[WUNTRACED(also stopped),WCONTINUED(continued),WNOHANG(no blocking)] macro(status)[WIFEXITED(status)-normal[WEXITSTATUS(status)-ex_status],WIFSIGNALED(status)-killed[WTERMSIG(s),WCOREDUMP(s)],WIFSTOPPED(s)[WSTOPSIG(s)],WIFCONTINUED(s)] #INCLUDES:<sys/wait.h>
PROCESS CREATION int waitid(idtype_t idtype,id_t,siginfo_t *infop,int options); RETURNS:0 on success or when async and no children to wait for or -1(error) idtype[P_ALL-all,P_PID-only pid=id,P_PGID-only pgid=id] options[WEXITED|WSTOPPED|WCONTINUED|WNOHANG|WNOWAIT] infop[si_code[CLD_EXITED&CLD_KILLED&CLD_STOPPED&CLD_CONTINUED],si_pid,si_status[exit status & stop/continue/terminate sig]]  #INCLUDES:<sys/wait.h>
PROCESS CREATION pid_t wait3(int *status,int options,struct rusage *rusage); RETURNS:pid of child or -1(error) #INCLUDES:<sys/resource.h><sys/wait.h>
PROCESS CREATION pid_t wait4(pid_t pid, int *status,int options,struct rusage *rusage); RETURNS:pid of child or -1(error) #INCLUDES:<sys/resource.h><sys/wait.h>

EXECUTION int execve(const char *pathname,char *const argv[],char *const envp[]); RETURNS:never or -1(error) #INCLUDES:<unistd.h>
EXECUTION int execle(const char *pathname,const char *arg,... /*, (char *) NULL,char *const envp[] */); RETURNS:never or -1(error) #INCLUDES:<unistd.h>
EXECUTION int execlp(const char *filename,const char *arg,... /*, (char *) NULL); RETURNS:never or -1(error) #INCLUDES:<unistd.h>
EXECUTION int execvp(const char *filename,char *const arg[]); RETURNS:never or -1(error) #INCLUDES:<unistd.h>
EXECUTION int execv(const char *pathname, char *const arg[]); RETURNS:never or -1(error) #INCLUDES:<unistd.h>
EXECUTION int execl(const char *pathname,const char *arg,... /*, (char *) NULL); RETURNS:never or -1(error) #INCLUDES:<unistd.h>
EXECUTION int fexecve(int fd,char *const argv[],char *const envp[]); RETURNS:never or -1(error) #INCLUDES:<unistd.h>
EXECUTION int system(const char *command); RETURNS:if command is NULL nonzero if shell is avail,0 if not,-1 if child couldnt be creted, if shell couldnt be execed in child returns -127,on all success, returns termination code of last command #INCLUDES:<stdlib.h>
EXECUTION int acct(const char *acctfile); RETURNS:0 or -1(error) if acctfile=NULL,turns off accounting, struct acct[char ac_flag,ac_uid,ac_gid,ac_tty,acbtime,ac_utime,ac_stime,ac_etime,ac_mem,ac_io,ac_rw,ac_minflt,ac_majflt,ac_swaps,ac_exitcodeac_comm[],ac_pad[]]  #INCLUDES:<unistd.h>
EXECUTION int clone(int (*func) (void *),void *child_stack,int flags,void *func_args,.../* pid_t *ptid, struct user_desc *tls, pid_t *ctid */); RETURNS: pid of child or -1(error) flags:lower byte is exitsignal,higherbytes:[CLONE_CHILD_CLEARTID,CLONE_CHILD_SETTID,CLONE_FILES,CLONE_FS,CLONE_IO,CLONE_NEWIPC,CLONE_NEWNET,CLONE_NEWNS,CLONE_NEWPID,CLONE_NEWUSER,CLONE_NEWUTS,CLONE_PARENT,CLONE_PARENT_SETTID,CLONEPID,CLONE_PTRACE,CLONE_SETTLS,CLONE_SIGHAND,CLONE_SYSVSEM,CLONE_THREAD,CLONE_UNTRACED,CLONE_VFORK,CLONE_VM]  #INCLUDES:<sched.h> 

THREADS int pthread_create(pthread_t *thread,const pthread_attr_t *attr,void *(*start)(void*),void *arg); RETURNS:0 or errno(error) #INCLUDES:<pthread.h>
THREADS void pthread_exit(void *retval); RETURNS:void #INCLUDES:<pthread.h>
THREADS pthread_t pthread_self(void); RETURNS:tid #INCLUDES:<pthread.h>
THREADS int pthread_equal(pthread_t t1,pthread_t t2); RETURNS:nonzero on equal, 0 on nonequal #INCLUDES:<pthread.h>
THREADS int pthread_join(pthread_t thread,void **retval); RETURNS:0 or poss errno(error); #INCLUDES:<pthread.h>
THREADS int pthread_detach(pthread_t thread); RETURNS:0 or pos errno(error); #INCLUDES:<pthread.h>
THREADS int pthread_mutex_lock(pthread_mutex_t *mutex); RETURNS:0 or pos errno(error) #INCLUDES:<pthread.h>
THREADS int pthread_mutex_unlock(pthread_mutex_t *mutex); RETURNS:0 or pos errno(error) #INCLUDES:<pthread.h>
THREADS int pthread_mutex_init(pthread_mutex_t *mutex,const pthread_mutexattr_t *attr); RETURNS:0 or pos errno(error) #INCLUDES:<pthread.h>
THREADS int pthread_mutex_destroy(pthread_mutex_t *mutex); RETURNS:0 or pos errno(error) #INCLUDES:<pthread.h>
THREADS int pthread_cond_signal(pthread_cond_t *cond); RETURNS:0 or ps errno(error) #INCLUDES:<pthread.h>
THREADS int pthread_cond_broadcast(pthread_cond_t *cond); RETURNS:0 or ps errno(error) #INCLUDES:<pthread.h>
THREADS int pthread_cond_wait(pthread_cond_t *cond,pthread_mutex_t *mutex); RETURNS:0 or ps errno(error) #INCLUDES:<pthread.h>
THREADS int pthread_cond_timedwait(pthread_cond_t *cond,mpthread_mutex_t *mutex,const struct timespec *abstime); RETURNS:0 or ps errno(error) #INCLUDES:<pthread.h>
THREADS int pthread_cond_init(pthread_cond_t *cond,const pthread_conattr_t *attr); RETURNS:0 or pos errno(error) #INCLUDES:<pthread.h>
THREADS int pthread_cond_destroy(pthread_cond_t *cond); RETURNS:0 or pos errno(error) #INCLUDES:<pthread.h>
THREADS int pthread_once(pthread_once_t *once_control,void (*init) (void)); RETURNS:0 or pos errno(error) #INCLUDES:<pthread.h>
THREADS int pthread_key_create(pthread_key_t *key,void(*destructor)(void *)); RETURNS:0 or pos errno(error) #INCLUDES:<pthread.h>
THREADS int pthread_setspecific(pthread_key_t key,const void *value); RETURNS:0 or pos errno(error) #INCLUDES:<pthread.h>
THREADS void *pthread_getspecific(pthread_key_t key); RETURNS:ptr or NULL(no thread specific data associated with key #INCLUDES:<pthread.h>
THREADS int pthread_cancel(pthread_t thread); RETURNS:0 or pos errno(error) #INCLUDES:<pthread.h>
THREADS int pthread_setcancelstate(int state,int *oldstate); RETURNS:0 or pos errno(error) state[PTHREAD_CANCEL_DISABLE,PTHREAD_CANCEL_ENABLE]  #INCLUDES:<pthread.h>
THREADS int pthread_setcanceltype(int type,int *oldtype); RETURNS:0 or pos errno(error) type[PTHREAD_CANCEL_ASYNCHRONOUS,PTHREAD_DEFERRED]   #INCLUDES:<pthread.h>
THREADS void pthread_testcancel(void); RETURNS:void #INCLUDES:<pthread.h>
THREADS void pthread_cleanup_push(void (*routine)(void*),void *arg); RETURNS:void #INCLUDES:<pthread.h>
THREADS void pthread_cleanup_pop(int execute); RETURNS:void execute<>0 handler executes #INCLUDES:<pthread.h>
THREADS int pthread_sigmask(int how,const sigset_t *set,sigset_t *oldset); RETURNS:0 or pos errno(error) #INCLUDES:<signal.h>
THREADS int pthread_kill(pthread_t thread,int sig); RETURNS:0 or pos errno(error) #INCLUDES:<signal.h>
THREADS int pthread_sigqueue(pthread_t thread,int sig,const union sigval value); RETURNS:0 or pos errno(error) #INCLUDES:<signal.h>
THREADS int sigwait(const sigset_t *set,int *sig); RETURNS:0 or pos errno(error) #INCLUDES:<signal.h>

PROC_GROUPS pid_t getpgrp(void); RETURNS:proc grp id of calling proc  #INCLUDES:<unistd.h>
PROC_GROUPS int setpgid(pid_t pid,pid_t pgid); RETURNS:0 or -1(error) #INCLUDES:<unistd.h>
PROC_GROUPS pid_t getsid(pid_t pid); RETURNS:session id of spec.proc or -1(error) #INCLUDES:<unistd.h>
PROC_GROUPS pid_t setsid(void); RETURNS:sessionid of new session or -1(error) #INCLUDES:<unistd.h>
PROC_GROUPS char *ctermid(char *ttyname); RETURNS:ptr to string containing path name of ctrl terminal or NULL if cannot be determined) #INCLUDES:<stdio.h>
PROC_GROUPS pid_t tcgetpgrp(int fd); RETURNS:proc grp id of terminals fg process grp or -1(errror) #INCLUDES:<unistd.h>
PROC_GROUPS int tcsetpgrp(int fd,pid_t pgid); RETURNS:0 or -1(error) #INCLUDES:<unistd.h>

PROC_PRIOR int getpriority(int which,id_t who); RETURNS:nice value ir -1(error) which[PRIO_PROCESS,PRIO_PGRP,PRIO_USER]  #INCLUDES:<sys/resource.h>
PROC_PRIOR int setpriority(int which,id_t who,int prio); RETURNS:0 or -1(error) which[PRIO_PROCESS,PRIO_PGRP,PRIO_USER] #INCLUDES:<sys/resource.h>
PROC_PRIOR int sched_get_priority_min(int policy); RETURNS: pos intprio or -1(error) #INCLUDES:<sched.h>
PROC_PRIOR int sched_get_priority_max(int policy); RETURNS: pos intprio or -1(error) #INCLUDES:<sched.h>
PROC_PRIOR int sched_setscheduler(pid_t pid,int policy,const struct sched_param *param); RETURNS:0 or -1(error) struct sched_param[int sched_priority] policy[SCHED_FIFO,SCHED_RR,SCHED_OTHER,SCHED_BATCH,SCHED_IDLE] #INCLUDES:<sched.h>
PROC_PRIOR int sched_setparam(pid_t pid,const struct sched_param *param); RETURNS:0 or -1(error) #INCLUDES:<sched.h>
PROC_PRIOR int sched_getscheduler(pid_t pid); RETURNS:sched policy or -1(error) #INCLUDES:<sched.h>
PROC_PRIOR int sched_getparam(pid_t pid,struct sched_param *param); RETURNS:0 or -1(error) #INCLUDES:<sched.h>
PROC_PRIOR int sched_yield(void); RETURNS: 0 or -1(error) #INCLUDES:<sched.h>
PROC_PRIOR int sched_rr_get_interval(pid_t pid,struct timespec *tp); RETURNS:0 or -1(error) struct timespec[tv_sec,tv_nsec] #INCLUDES:<sched.h>
PROC_PRIOR int sched_setaffinity(pid_t pid,size_t len,cpu_set_t *set); RETURNS:0 or -1(error) #INCLUDES:<sched.h>
PROC_PRIOR void CPU_ZERO(cpu_set_t *set); RETURNS:void #INCLUDES:<sched.h>
PROC_PRIOR void CPU_SET(int cpu,cpu_set_t *set); RETURNS:void #INCLUDES:<sched.h>
PROC_PRIOR void CPU_CLR(int cpu,cpu_set_t *set); RETURNS:void #INCLUDES:<sched.h>
PROC_PRIOR int CPU_ISSET(int cpu,cpu_set_t *set); RETURNS:1 if cpu is in set or 0 otherwise #INCLUDES:<sched.h>
PROC_PRIOR int sched_getaffinity(pid_t pid,size_t len,cpu_set_t *set); RETURNS:0 or -1(error) #INCLUDES:<sched.h>

PROC_RESOURCES int getrusage(int who,struct rusage *res_usage); RETURNS:0 or -1(error) who[RUSAGE_SELF,RUSAGE_CHILDREN,RUSAGE_THREAD] struct rusage[struct timeval ru_utime,struct timeval ru_stime,long maxrss,long ru_minflt,long rumajflt,long ru_inblock,long ru_oublock,long ru_nvcsw,long ru_nivcsw]  #INCLUDES:<sys/resource.h>
PROC_RESOURCES int getrlimit(int resource,struct rlimit *rlim); RETURNS:0 or -1(error) struct rlimit[rlim_cur,rlim_max] resource[RLIMIT_AS,RLIMIT_CORE,RLIMIT_CPU,RLIMIT_DATA,RLIMIT_FSIZE,RLIMIT_MEMLOCK,RLIMIT_MSGQUEUE,RLIMIT_NICE,RLIMIT_NOFILE,RLIMIT_NPROC,RLIMIT_RSS,RLIMIT_RTPRIO,RLIMIT_RTTIME,RLIMIT_SIGPENDING,RLIMIT_STACK] #INCLUDES:<sys/resource.h>
PROC_RESOURCES int setrlimit(int resource,const struct rlimit *rlim); RETURNS:0 or -1(error) struct rlimit[rlim_cur,rlim_max] resource[RLIMIT_AS,RLIMIT_CORE,RLIMIT_CPU,RLIMIT_DATA,RLIMIT_FSIZE,RLIMIT_MEMLOCK,RLIMIT_MSGQUEUE,RLIMIT_NICE,RLIMIT_NOFILE,RLIMIT_NPROC,RLIMIT_RSS,RLIMIT_RTPRIO,RLIMIT_RTTIME,RLIMIT_SIGPENDING,RLIMIT_STACK] #INCLUDES:<sys/resource.h>

DAEMONS int becomeDaemon(int flags); RETURNS:0 or -1(error) flags[BD_NO_CHDIR,BD_NO_CLOSE_FILES,BD_NO_REOPEN_STD_FDS,BD_NO_UMASKO,BD_MAX_CLOSE] #INCLUDES:<syslog.h>
DAEMONS void openlog(const char *ident,int log_options,int facility); RETURNS:void log_options[LOG_CONS,LOG_NDELAY,LOG_NOWAIT,LOG_ODELAY,LOG_PERROR,LOG_PID] facility[ LOG_AUTH,LOG_AUTHPRIV,LOG_CRON,LOG_DAEMON,LOG_FTP,LOG_KERN,LOG_LOCALO,LOG_LPR,LOG_MAIL,LOG_NEWS,LOG_SYSLOG,LOG_USER,LOG_UUCP]  #INCLUDES:<syslog.h>
DAEMONS void syslog(int priority,const char *format,...); RETURNS:void priority[LOG_EMERG,LOG_ALERT,LOG_CRIT,LOG_ERR,LOG_WARNING,LOG_NOTICE,LOG_INFO,LOG_DEBUG] #INCLUDES:<syslog.h>
DAEMONS void closelog(void); RETURNS:void #INCLUDES:<syslog.h>
DAEMONS int setlogmask(int mask_priority); RETURNS:previous log prior mask #INCLUDES:<syslog.h>

LOGIN_ACCOUNTING void setutxent(void); RETURNS:void #INCLUDES:<utmpx.h>
LOGIN_ACCOUNTING void endutxent(void); RETURNS:vopid #INCLUDES:<utmpx.h>
LOGIN_ACCOUNTING struct utmpx *getutxent(void); RETURNS:ptr to a statically allocated utmpx struct or NULL if no matching struct utmpx[short ut_type,pid_t ut_pid, char ut_line[32],char ut_id[4],char ut_user[32],char ut_host[256],struct exit_status ut_exit,long ut_session,struct timeval ut_tv,int32_t ut_addr_v6[4],char __unused] struct exit_status[short e_termination,short e_exit] #INCLUDES:<utmpx.h>
LOGIN_ACCOUNTING struct utmpx *getutxid(const struct utmpx *ut); RETURNS:ptr to a statically allocated utmpx struct or NULL if no matching ut_type[RUN_LVL,BOOT_TIME,NEW_TIME,OLD_TIME,INIT_PROCESS,LOGIN_PROCESS,USER_PROCESS,DEAD_PROCESS] #INCLUDES:<utmpx.h>
LOGIN_ACCOUNTING struct utmpx *getutxline(const struct utmpx *ut); RETURNS:ptr to a statically allocated utmpx struct or NULL if no matching #INCLUDES:<utmpx.h>
LOGIN_ACCOUNTING int utmpxname(const char *file); RETURNS:0 or -1(error) #INCLUDES:<utmpx.h>
LOGIN_ACCOUNTING char *getlogin(void); RETURNS:ptr to username string or NULL(error) #INCLUDES:<unistd.h>
LOGIN_ACCOUNTING struct utmpx *pututxline(const struct utmpx *ut); RETURNS:ptr to copy of successfuly updated record or NULL(error) #INCLUDES<utmpx.h>
LOGIN_ACCOUNTING void updwtmpx(const char *wtmpx_file,const struct utmpx *ut); RETURNS:void #INCLUDES:<utmpx.h>

SHARED_LIB void *dlopen(const char *libfilename,int flags) RETURNS:libhandle or NULL(error) flags[RTLD,RTLD_NOW,RTLD_GLOBAL,RTLD_LOCAL,RTLD_NODELETE,RTLD_NOLOAD,RTLD_DEEPBIND] #INCLUDES:<dlfcn.h>
SHARED_LIB const char *dlerror(void); RETURNS:ptr to err diagnostic string or NULL if no err #INCLUDES:<dlfcn.h>
SHARED_LIB void *dlsym(void *handle,char *symbol); RETURNS:address of symbol or NULL if not found pseudohandles[RTLD_DEFAULT,RTLD_NEXT] #INCLUDES:<dlfcn.h>
SHARED_LIB int dlclose(void *handle); RETURNS:0 or -1(error) #INCLUDES:<dlfcn.h>
SHARED_LIB int dladdr(const void *addr,Dl_info *info); RETURNS:nonzero if addr was found otherwise 0 #INCLUDES:<dlfcn.h>

PIPES_FIFOS int pipe(int filedes[2]); RETURNS:0 or -1(error) #INCLUDES:<unistd.h>
PIPES_FIFOS FILE *popen(const char *command,const char *mode); RETURNS: file stream or NULL(error) mode[r,w]  #INCLUDES:<stdio.h>
PIPES_FIFOS int pclose(FILE *stream); RETURNS:term status of child proc or -1(err) #INCLUDES:<stdio.h>
PIPES_FIFOS int mkfifo(const char *pathname,mode_t mode); RETURNS:0 or -1(err) #INCLUDES:<sys/stat.h>





